<!DOCTYPE html>
<html>
<head>
<meta charset="EUC-KR">
<title>Insert title here</title>
<style type="text/css">
html,
body {
  height: 100%;
  overflow: hidden;
}
.Loop {
  position: relative;
  height: 100%;
  overflow: auto;
}
section {
  position: relative;
  text-align: center;
  min-height: 300px;
  max-height: 700px;
  height: 80%;
}
::scrollbar {
  display: none;
}
body {
  font-family: "Avenir Next", Helvetica, sans-serif;
  font-weight: normal;
  font-size: 100%;
}
.red {
  background: #FF4136;
}
.green {
  background: #2ECC40;
}
.blue {
  background: #0074D9;
}
.orange {
  background: rebeccapurple;
}
h1 {
  margin: 0;
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  width: 100%;
  font-size: 80px;
  letter-spacing: 5px;
  color: #fff;
  text-transform: uppercase;
}
#STATICMENU { margin: 0pt; padding: 0pt;  position:absolute; right: 0px; top: 0px; height:30pt; width:23px;'}
</style>

<script type="text/javascript">
/*
Ininite looping scroll.
Tested and works well in latest verions of Chrome, Safari and Firefox.
Not built/tested for mobile.
*/

var stmnLEFT = 10; // 오른쪽 여백 
var stmnGAP1 = 0; // 위쪽 여백 
var stmnGAP2 = 150; // 스크롤시 브라우저 위쪽과 떨어지는 거리 
var stmnBASE = 150; // 스크롤 시작위치 
var stmnActivateSpeed = 35; //스크롤을 인식하는 딜레이 (숫자가 클수록 느리게 인식)
var stmnScrollSpeed = 20; //스크롤 속도 (클수록 느림)
var stmnTimer; 
var flag = 0;

function RefreshStaticMenu() { 
 var stmnStartPoint, stmnEndPoint; 
 stmnStartPoint = parseInt(document.getElementById('STATICMENU').style.top, 10); 
 stmnEndPoint = Math.max(document.documentElement.scrollTop, document.body.scrollTop) + stmnGAP2; 
 if (stmnEndPoint < stmnGAP1) stmnEndPoint = stmnGAP1; 
 if (stmnStartPoint != stmnEndPoint) { 
  stmnScrollAmount = Math.ceil( Math.abs( stmnEndPoint - stmnStartPoint ) / 15 ); 
  document.getElementById('STATICMENU').style.top = parseInt(document.getElementById('STATICMENU').style.top, 10) + ( ( stmnEndPoint<stmnStartPoint ) ? -stmnScrollAmount : stmnScrollAmount ) + 'px'; 
  stmnRefreshTimer = stmnScrollSpeed; 
  }
 stmnTimer = setTimeout("RefreshStaticMenu();", stmnActivateSpeed); 
 } 
function InitializeStaticMenu() {
 document.getElementById('STATICMENU').style.backgroundColor="#dde8f0"; //크기 보고 싶어서 색 바꿔 놓음 #dde8f0
 document.getElementById('STATICMENU').style.right = stmnLEFT + 'px';  //처음에 오른쪽에 위치. left로 바꿔도.
 document.getElementById('STATICMENU').style.top = document.body.scrollTop + stmnBASE + 'px'; 
 RefreshStaticMenu();
 }

function click_test(){
	var obj = document.getElementById('STATICMENU');
	 
	if(flag == 0)
	{
		
		var btnupdate = document.createElement('input');
	    btnupdate.setAttribute('id', 'b1');
	    btnupdate.setAttribute('type', 'button');
	    btnupdate.setAttribute('value', '1');
	    btnupdate.setAttribute('style','position :relative; bottom:70px ; border-radius : 150px; solid : #0000')
	    btnupdate.onclick = function() {  alert('test');  };
	    obj.appendChild(btnupdate);
	    
	    var btnupdate = document.createElement('input');
	    btnupdate.setAttribute('id', 'b2');
	    btnupdate.setAttribute('type', 'button');
	    btnupdate.setAttribute('value', '2');
	    btnupdate.setAttribute('style','position :relative; right : 30px; bottom :87px ; border-radius : 150px; solid : #0000')
	    btnupdate.onclick = function() {  alert('test');  };
	    obj.appendChild(btnupdate);
	    
	    var btnupdate = document.createElement('input');
	    btnupdate.setAttribute('id', 'b3');
	    btnupdate.setAttribute('type', 'button');
	    btnupdate.setAttribute('value', '3');
	    btnupdate.setAttribute('style','position :relative; right :35px; bottom : 89px ; border-radius : 150px; solid : #0000')
	    btnupdate.onclick = function() {  alert('test');  };
	    obj.appendChild(btnupdate);
	    
	    var btnupdate = document.createElement('input');
	    btnupdate.setAttribute('id', 'b4');
	    btnupdate.setAttribute('type', 'button');
	    btnupdate.setAttribute('value', '4');
	    btnupdate.setAttribute('style','position :relative; right :30px; bottom:90px ; border-radius : 150px; solid : #0000')
	    btnupdate.onclick = function() {  alert('test');  };
	    obj.appendChild(btnupdate); 
	    
	    flag = 1;
	}
	
	else if(flag == 1)
	{
		var btn = document.getElementById("b1");
		obj.removeChild(btn);
		
		var btn = document.getElementById("b2");
		obj.removeChild(btn);
		
		var btn = document.getElementById("b3");
		obj.removeChild(btn);
		
		var btn = document.getElementById("b4");
		obj.removeChild(btn);
		
		flag = 0;
	}
	
	
}

'use strict';
var doc = window.document,
  context = doc.getElementsByClassName('js-loop')[0],
  clones = context.getElementsByClassName('is-clone'),
  disableScroll,
  scrollHeight,
  scrollPos,
  clonesHeight,
  i;
function getScrollPos() {
  return (context.pageYOffset || context.scrollTop) - (context.clientTop || 0);
}
function setScrollPos(pos) {
  context.scrollTop = pos;
}
function getClonesHeight() {
  clonesHeight = 0;
  i = 0;
  for (i; i < clones.length; i += 1) {
    clonesHeight = clonesHeight + clones[i].offsetHeight;
  }
  return clonesHeight;
}
function reCalc() {
  scrollPos = getScrollPos();
  scrollHeight = context.scrollHeight;
  clonesHeight = getClonesHeight();
  if (scrollPos <= 0) {
    setScrollPos(1); // Scroll 1 pixel to allow upwards scrolling
  }
}
// Calculate variables
window.requestAnimationFrame(reCalc);
function scrollUpdate() {
  if (!disableScroll) {
    scrollPos = getScrollPos();
    if (clonesHeight + scrollPos >= scrollHeight) {
      // Scroll to the top when you¡¯ve reached the bottom
      setScrollPos(1); // Scroll down 1 pixel to allow upwards scrolling
      disableScroll = true;
    } else if (scrollPos <= 0) {
      // Scroll to the bottom when you reach the top
      setScrollPos(scrollHeight - clonesHeight);
      disableScroll = true;
    }
  }
  if (disableScroll) {
    // Disable scroll-jumping for a short time to avoid flickering
    window.setTimeout(function () {
      disableScroll = false;
    }, 40);
  }
}
context.addEventListener('scroll', function () {
  window.requestAnimationFrame(scrollUpdate);
}, false);
window.addEventListener('resize', function () {
  window.requestAnimationFrame(reCalc);
}, false);
// Just for the demo: Center the middle block on page load
window.onload = function () {
  setScrollPos(Math.round(clones[0].getBoundingClientRect().top + getScrollPos() - (window.innerHeight - clones[0].offsetHeight) / 2));
};
</script>

</head>
<body onload="InitializeStaticMenu();">
<div id="STATICMENU">
<form>
<input type = 'button' value='R' onclick='click_test()' 
	style = "background-color : #3e779d; border : 10px; solid : #0000; border-radius : 4px; height:30pt; width : 18pt;">
</form>
</div>
<main class="Loop js-loop">
  <section class="green">
    <h1>One</h1>
  </section>
  <section class="red">
    <h1>Two</h1>
  </section>
  <section class="blue">
    <h1>Three</h1>
  </section>
  <section class="orange">
    <h1>Four</h1>
  </section>
  

  <!--
  These blocks are the same as the first blocks to get that looping illusion going. You need to add clones to fill out a full viewport height.
  -->
  <section class="green is-clone">
    <h1>One</h1>
  </section>
  <section class="red is-clone">
    <h1>Two</h1>
  </section>
  <section class="blue is-clone">
    <h1>Three</h1>
  </section>
  <section class="orange is-clone">
    <h1>Four</h1>
  </section>
</main>



</body>
</html>